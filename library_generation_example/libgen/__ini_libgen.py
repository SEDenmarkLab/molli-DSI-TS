"""
This file seeks to construct the library of DSI-substrate pairs that approximate
the computed transition states. The workflow will differ from the typical one
using Molli because the base structure will not start from a CDXML file.

However, the fragments likely need to be constructed from CDXML files.

Need to construct a molli object for the base structure (can be lazy and
have one for each of the 13 DSI-Substrate pairs). 

Starting from Mol2 files that already contain bonding information is likely
the easiest way. These can be generated with Spartan. 

First test: Generate Molli objects with Spartan generated Mol2 files

2012-12-26
this file also generates conformers of the joined structures using RDKit, but makes sure
that the correct atoms are locked

"""

print("WARNING - changed concurrent to 6")

import molli as ml
import glob
import os
import numpy as np
import pandas as pd


#molli imports
from molli.dtypes import CartesianGeometry


#RDKit imports
from rdkit import Chem
from rdkit.Chem import AllChem
from rdkit.Chem import Draw,PyMol,MCS
from rdkit import rdBase

#other imports
import subprocess 
import random
import asyncio 
import os 
import re 
from copy import deepcopy
import numpy as np
from multiprocessing import Pool
import time

import substructure #### CHANGE TO rdkittools
from rdkit.Chem import GetPeriodicTable

import networkx as nx #networkx for graphs
from networkx.algorithms import isomorphism
#custom imports:
#import get_pid



#########################################################################################################
################################### run_constrained_embed ###############################################

def run_constrained_embed(_full_mol_copy, _full_mol_frag, rand_seed):
    """
    Wrapper function for ConstrainedEmbed to be executed in parallel.
    :param rand_seed: Seed for random number generator.
    :return: The conformer generated by ConstrainedEmbed.
    """
    # Example usage of parameters. Adjust accordingly to your specific needs.
    ## KSP MOD 5/18/2024
    #_conf = AllChem.ConstrainedEmbed(_full_mol_copy, _full_mol_frag, useTethers=False, randomseed=rand_seed)
    
    GetFF=lambda x,confId=-1:AllChem.MMFFGetMoleculeForceField(x,AllChem.MMFFGetMoleculeProperties(x),confId=confId)
    _conf = AllChem.ConstrainedEmbed(_full_mol_copy, _full_mol_frag, useTethers=False, randomseed=rand_seed, getForceField=GetFF)
    return _conf
#########################################################################################################
#########################################################################################################
import configparser

def parse_config(filepath):
    config = configparser.ConfigParser(inline_comment_prefixes=('#', ';'))
    config.read(filepath)

    section = 'libgen'
    if section not in config:
        raise ValueError(f"Missing expected section: [{section}]")

    data = config[section]

    # Extract and parse values
    substrate_atom       = data.get('substrate_atom')
    central_atom         = data.get('central_atom')
    central_atom_label   = data.get('central_atom_label')
    fragment_labels      = data.getboolean('fragment_labels', fallback=True)

    join_atoms_raw       = data.get('join_atoms', fallback='')
    join_atoms           = [x.strip() for x in join_atoms_raw.split(',')] if join_atoms_raw else []

    swapped_atom         = data.getint('swapped_atom', fallback=16)

    custom_crest_lock    = data.getboolean('custom_crest_lock', fallback=False)

    crest_lock_list_raw  = data.get('crest_lock_list', fallback=None)
    if crest_lock_list_raw in (None, 'None', ''):
        crest_lock_list = None
    else:
        crest_lock_list = [int(x.strip()) for x in crest_lock_list_raw.split(',')]

    rdkit_confs          = data.getint('rdkit_confs', fallback=8)
    rdkit_multithreading = data.getboolean('rdkit_multithreading', fallback=True)

    long_bond_opt        = data.get('long_bond_opt')
    final_opt            = data.get('final_opt')

    return {
        'substrate_atom': substrate_atom,
        'central_atom': central_atom,
        'central_atom_label': central_atom_label,
        'fragment_labels': fragment_labels,
        'join_atoms': join_atoms,
        'swapped_atom': swapped_atom,
        'custom_crest_lock': custom_crest_lock,
        'crest_lock_list': crest_lock_list,
        'rdkit_confs': rdkit_confs,
        'rdkit_multithreading': rdkit_multithreading,
        'long_bond_opt': long_bond_opt,
        'final_opt': final_opt
    }

config_vars = parse_config(f"variables.ini")
print(config_vars['join_atoms'])

"""
important information:

molecule name variables:
1] base_file -> e.g., "../R-ax-S_2a.mol2", base_file[3:] = "R-ax-S_2a.mol2"
2] mol2file  -> e.g., "../fragment_mol2/obabel_ClC#Cc1ccc_C_F__F_F_cc1_tmp.xyz_to.mol2", mol2file[17:] = "obabel_ClC#Cc1ccc_C_F__F_F_cc1_tmp.xyz_to.mol2"

dummy atoms:
alkyne fragment: CL
DSI-backbone: Li/Na

"""

for base_file in glob.glob("../*.mol2"):
    ## Parsing the Spartin generated mol2 file works only after removing
    ## spaces before "@<TRIPOS>BOND" 
    try:
        del mol1
        del join1
        del join2
    except:
        pass
    
    #create molecule collections for fragments and core
    #
    #create a collection for the base structure
    mol1 = ml.Molecule.from_mol2(base_file, f"BASE_TS_{base_file[3:]}")
    TS_frags = [mol1] # make it an iterable. Add more molecules later...    
    collect1 = ml.Collection("TS_structures", TS_frags) # this needs to be passed an iterable
    #create molecule objects from the alkyne fragment list so that a collection can be generated
    molecules = []
    counter = 0
    for mol2file in glob.glob("../fragment_mol2/*xyz_to.mol2"):
        print(mol2file)
        print(mol2file[17:])
        if(counter<100):
            molecules.append(ml.Molecule.from_mol2(mol2file, name = mol2file[17:]))
        counter = counter+1
    #prepare the fragments created by RDKit (replace "CL" with the atom used in the substituent list
    #       passed to "SubstituentCreate()"
    #create the collection
    for molecule in molecules:
        #@@ molecule.atoms[molecule.get_atom_idx("CL")].swap(newlabel="D") 
        molecule.atoms[molecule.get_atom_idx(config_vars['substrate_atom'])].swap(newlabel="D")
    fragment_collect = ml.Collection("molecule_test", molecules)

    #instantiate xtb/crest drivers with 16 processors each
    xtb = ml.XTBDriver("sxtb", scratch_dir="./xtb_scr", nprocs=16)
    crest = ml.CRESTDriver("crest", scratch_dir="./crest_scr2", nprocs=16)
    
    #generate the library
    #
    #
    # find the iodine, as it will serve as the central point in the base fragment for the fragment rotations
    for j,joining in enumerate(config_vars['join_atoms']):
        print(j)
        print(config_vars['join_atoms'][0])

    #
    #join the first alkyne
    cent = config_vars['central_atom']

    if(config_vars['fragment_labels'] == True):
        ml.librarygenerate.label_collection(collect1, 1)
        ml.librarygenerate.label_collection(fragment_collect, 2) # label the first alkyne "2"
    join1 = ml.Collection.join(collect1, fragment_collect, config_vars['join_atoms'][0], "D", 4.1, 1, addname="--one-name", rotations=[2,5], central_atom = [cent if cent=="unique" else "centroid"])
    join1.to_multixyz("join1_test.xyz") #output joined structure (no bond)
    for j,joined_atom in enumerate(config_vars['join_atoms'][1:]):
        if(config_vars['fragment_labels'] == True):
            ml.librarygenerate.label_collection(fragment_collect, j+2) # label the second alkyne "3"
        print("huh", j)
        join2 = ml.Collection.join(join1, fragment_collect, joined_atom, "D", 4.1, 1,jointype="zip", rotations=[2,5], central_atom = [cent if cent=="unique" else "centroid"])# , addname="--one-name")
        join2.to_multixyz(f"join{j+2}_test.xyz") #output joined structure (no bonds)
            

    """ #@@
    ml.librarygenerate.label_collection(collect1, 1) # label the base structure "1"
    ml.librarygenerate.label_collection(fragment_collect, 2) # label the first alkyne "2"
    central_atom = collect1[0].get_atom_idx("I") # get the atom index as a handle
    join1 = ml.Collection.join(collect1, fragment_collect, "Li", "D", 4.1, 1, addname="--one-name", rotations=[2,5], central_atom = central_atom)
    join1.to_multixyz("join1_test.xyz") #output joined structure (no bond)
    #join the second alkyne - need to use jointype = "zip" to avoid comb. enum. (results in mixing of alkynes)
    #y=input("wut")
    central_atom = join1[0].get_atom_idx("I") # get the atom index as a handle - should remain the same, but just in case
    ml.librarygenerate.label_collection(fragment_collect, 2) # label the second alkyne "3"
    join2 = ml.Collection.join(join1, fragment_collect, "Na", "D", 4.1, 1,jointype="zip", rotations=[2,5], central_atom = central_atom)# , addname="--one-name")
    join2.to_multixyz("join2_test.xyz") #output joined structure (no bonds)

    """
    
    # the following code identifies the transition state core automatically in each structure
    # this code should be replaced as needed for new structures
    #
    # step 1: find the iodine atom (it is unique in each transition state), you can use substructure matching as well
    #           use the iodine to trace bonds until nitrogens are found, collect them

    ### \/
    proton_source = ml.librarygenerate.mol2_to_mol(join2[0], sanitize = False, removeHs = False)#, name=f"{xtbmol.name}_original.mol")
    highvalent_list , _ = substructure.swap_high_valent(proton_source, swapped_atom = config_vars['swapped_atom']) #identify the active proton by its presence as the only "high valent proton"!
    _proton = next((k for k, v in highvalent_list.items() if v == 'H'), None)
    
    if(config_vars['custom_crest_lock']):
        atomlist = [join2[0].atoms[x] for x in config_vars['crest_lock_list']]
    else:
        atomlist, bondlist = join2[0].recursive_atoms(join2[0].atoms[_proton], n=4)

    #generate the list of atoms to lock for crest...
    atom_lock = ml.librarygenerate.get_crest_lock_list(join2[0], atomlist)
    ml.librarygenerate.print_labels(join2, base_file[3:])
    

    #printout the atom labels for the molecules (now joined)
    #this helps keep track of the substituents for descriptors
    #$%
    


    #fix initially generated structure with longbond join for TS structures
    _xtb_longbondfix = ml.Concurrent(join2, backup_dir="./xtb_scr3", logfile = f"out.log", concurrent=2, update=30, timeout = None)(xtb.fix_long_bonds_TS2)(force_const=6.0, method=config_vars['long_bond_opt'], TS_bonds=[atom_lock])
    xtb_optimize_test = ml.Collection("test123", _xtb_longbondfix)
    xtb_optimize_test.to_multixyz(f"{base_file[3:]}_GFF_structure_gen.xyz")
    xtb_optimize_test.to_zip(f"{base_file[3:]}_GFF_structure_gen.zip")
    
    
    #### test obabel mol2 -> mol conversion so that the structure topology can be read in by RDKit
    

    
    locked_mol = mol1
    #oops, in _full_mol_frag (which is the base_TS structure), the Li/Na atoms were kept, which resulted in the first alkynic atoms being kept in "alkynes_list")
    #see below...
    #let's remove the atoms (recall, delete from locked_mol!)

    for atom in config_vars['join_atoms']:
        locked_mol.remove_atoms(locked_mol.get_atom(atom))

    #locked_mol.remove_atoms(locked_mol.get_atom("Li")) #remove the Li dummy atom from locked_mol so that it doesn't contaminate the workflow
    #locked_mol.remove_atoms(locked_mol.get_atom("Na")) #also remove the Na dummy atom...
    
    
    #the following code generates conformers with RDKit
    #the code is heavily customized here for the DSI-TS structure, this part can be replaced with a separate conformer generation method
    #note that some atoms need to be swapped to accomodate the increase in valency (e.g., N--H--C fragment). 
    #this has no impact on conformer generation as these atoms are frozen
    replaced_atoms = [] #this is the array that holds the indexes for the replaced atoms.
                        #change these back after RDKit ConstrainEmbed(), but before xtb geometry minimizations
    for xtbmol in xtb_optimize_test:

        
        #convert molli mol to rdkit mol,
        original_atoms = ml.librarygenerate.mol2_to_mol(xtbmol, sanitize = False, removeHs = False)#, name=f"{xtbmol.name}_original.mol")
        swapped_list, _ = substructure.swap_high_valent(original_atoms, swapped_atom = config_vars['swapped_atom'])
        replaced_atoms = list(swapped_list.keys())[::-1]

        for item in swapped_list:
            xtbmol.atoms[item].swap(GetPeriodicTable().GetElementSymbol(config_vars['swapped_atom']))
            #xtbmol.atoms[item].swap("S")
        exit()
        tsmolobj = ml.librarygenerate.mol2_to_mol(xtbmol, sanitize = False, removeHs = False) #rewrite the molecule

        #convert molli-readable mol2 files to rdkit-readable .mol files with openbabel:
        #base_mol = ml.librarygenerate.mol2_to_mol(base_mol, sanitize = False)
        _full_mol = ml.librarygenerate.mol2_to_mol(xtbmol, sanitize = True, removeHs = False)
        #>^_full_mol = ml.librarygenerate.mol2_to_mol(xtb_swapped, sanitize = True, removeHs = False)
        _full_mol_frag = Chem.EditableMol(Chem.MolFromMolFile(f"./{xtbmol.name}_obabel.mol", sanitize=True, removeHs = False)) # get another molecule so we can create a base_framework...
        
        full_atom_list = [item for item in range(len(xtbmol.geom.coord))] #in order
        base_atom_list = [item for item in range(len(locked_mol.geom.coord))] #in order because the alkynes are added separately
        alkynes_list = [item for item in full_atom_list if item not in base_atom_list] #in order as the differences between the lists is collected
        for idx in sorted(alkynes_list, reverse=True): #constrain it on the transition structure
            _full_mol_frag.RemoveAtom(idx)        
        _full_mol_frag = _full_mol_frag.GetMol()
        
        _full_mol_copy = deepcopy(_full_mol)
        #generate the rdkit conformers
        ml.librarygenerate.rdkitconfs(xtbmol, _full_mol_copy, _full_mol_frag, num_confs = 8)


        #the following code does nothing productive, but demonstrates substructure searching functionality
        DSI_backbone_smi = "O=S1(C2=C(C3=C([H])C([H])=C([H])C([H])=C3C([H])=C2)C4=C5C([H])=C([H])C([H])=C([H])C5=C([H])C=C4S(N1[H])(=O)=O)=O" # "O=S1(C2=C(C3=C(C=CC=C4)C4=CC=C3S([N]1)(=O)=O)C5=CC=CC=C5C=C2)=O"  
        DSI_mol = Chem.MolFromSmiles(DSI_backbone_smi, sanitize=False)
        DSI_mol_nx = substructure.mol_to_nx(DSI_mol)
        tsmolgraph = substructure.mol_to_nx(tsmolobj)
        matches = substructure.subgraph_matches_nx(DSI_mol_nx, tsmolgraph)


        #instead of iterating through the molecules again, just swap back the atoms here...
        #the atoms are in "replaced_atoms", the hydrogen atom is first, followed by the carbon atom
        if(xtbmol.atoms[replaced_atoms[0]].label == "S" and xtbmol.atoms[replaced_atoms[1]].label == "S"):
            xtbmol.atoms[replaced_atoms[0]].swap("H")
            xtbmol.atoms[replaced_atoms[1]].swap("C")
        #atoms are replaced now, and should be OK to be put into xtb for geometry optimization+energy calculations
    # end RDKit based conformer generation (replace above with different method if desired)
    
    #once the conformers are generated, reminimize with xtb
    #current modification has xtb_optimize_test being modified "inplace". let's see if that works better...
    _xtb_minimized = ml.Concurrent(xtb_optimize_test, backup_dir="./xtb_scr5", logfile = f"out_minimized2.log", concurrent=6, update=30, timeout=None)(xtb.optimize_conformers_TS)(force_const=6.0, method=config_vars['final_opt'], TS_bonds=[atom_lock])
    xtb_minimized = deepcopy(xtb_optimize_test) #this is to avoid changing the name of all the following variables...

    #prune the molecules, keep the lowest energy conformer
    for molecule in xtb_minimized:
        #molecule.conformer_energies = asyncio.run(xtb.conformer_energies(molecule, method="gfn2"))
        molecule.conformer_energies = asyncio.run(xtb.conformer_energies_independent(molecule, method="gfn2")) # new version, test
        #keep lowest energy
        _loc = np.where(molecule.conformer_energies==(molecule.conformer_energies.min()))[-1].squeeze()
        #On rare occasions, _loc gets two structures due to degeneracies. 
        try:
            if(len(_loc)>1):
              _loc = _loc[0]
        except:
            pass
        molecule.update_geom_from_xyz(molecule.to_xyz(n=_loc, header=True))



    xtb_minimized.to_multixyz(f"final_multi_xyz_{base_file[3:]}_xtb_minimized_inplace_mod_gfn2.xyz")
    xtb_minimized.to_zip(f"final_zip_{base_file[3:]}_xtb_inplace_mod_minimized_gfn2.zip")

    ############################################################################################################################################################################
    ###################################################################################### checking RSSD #######################################################################
    print("======================================")
    angle_data = "number, name, angle\n"
    for n, molecule in enumerate(xtb_minimized):
    
      
        ## the above checks the alignment of the TS core structure with the Kabsch algorithm, unfortunately, the backbone doesn't change very much
        ## failures in the alignment are due to non-linear alkynes. This should be adjusted here.
    
        #lets make the Kabsch check general, in the sense that we don't have to specify the exact number of atoms
        #base_TS_len = len(mol1.geom.coord[:-2]) #get the length of the base_TS (will change depending on the exact substrate used
        #print("Kabsch: ", Rotation.align_vectors(mol1.geom.coord[:-2], molecule.geom.coord[0:base_TS_len]))
    
        # lets also check how linear the alkyne is! the indices sp2(binol)-sp(alkyne)-sp(alkyne) chain of three atoms are found within join1[n].important_atoms and join2[n].important_atoms
        # note that xtb_optimize_test is a collection that contains the actual atoms (after optimization). This collection contains the geometries that should be examined!
        
        v1 = molecule.geom.coord[join1[n].important_atoms[0]]-molecule.geom.coord[join1[n].important_atoms[1]-3]
        v2 = molecule.geom.coord[join1[n].important_atoms[1]-3]-molecule.geom.coord[join1[n].important_atoms[2]-3]

        dot_product = np.dot(v1, v2)
        norm_v1 = np.linalg.norm(v1)
        norm_v2 = np.linalg.norm(v2)
        
        cos_angle = dot_product/(norm_v1*norm_v2)
        cos_angle = np.clip(cos_angle,-1,1)
        angle_radians = np.arccos(cos_angle)
        angle_degrees = np.degrees(angle_radians)
        
        print("ANGLE:", angle_degrees)
        angle_data += f"{n}, {molecule.name}, {angle_degrees}\n"
        

    with open(f"{base_file[3:]}_angle_checks", "w+") as f:
        f.write(angle_data)

    #clean up
    del join1
    del join2
    
### end large for loop (iterating through each structure)


print("completed, exiting...")
exit()   



