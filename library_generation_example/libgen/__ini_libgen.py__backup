"""
This file seeks to construct the library of DSI-substrate pairs that approximate
the computed transition states. The workflow will differ from the typical one
using Molli because the base structure will not start from a CDXML file.

However, the fragments likely need to be constructed from CDXML files.

Need to construct a molli object for the base structure (can be lazy and
have one for each of the 13 DSI-Substrate pairs). 

Starting from Mol2 files that already contain bonding information is likely
the easiest way. These can be generated with Spartan. 

First test: Generate Molli objects with Spartan generated Mol2 files

2012-12-26
this file also generates conformers of the joined structures using RDKit, but makes sure
that the correct atoms are locked

"""

print("WARNING - changed concurrent to 6")

import molli as ml
import glob
import os
import numpy as np
import pandas as pd


#molli imports
from molli.dtypes import CartesianGeometry

#RDKit imports
from rdkit import Chem
from rdkit.Chem import AllChem
from rdkit.Chem import Draw,PyMol,MCS
from rdkit import rdBase

#other imports
import subprocess 
import random
import asyncio 
import os 
import re 
from copy import deepcopy
import numpy as np
from multiprocessing import Pool
import time

#custom imports:
#import get_pid



def remove_numbers_from_pattern(content):
    """
    Removes numbers from specific patterns in the text file.
    The pattern is one or two letters followed by one or two numbers.

    Parameters:
    file_path (str): Path to the text file.

    Returns:
    None; It updates the file in place.
    """
    # Define the regular expression pattern
    pattern = re.compile(r'([A-Za-z]{1,2})(\d{1,2})')

    # Function to replace matched pattern with only the letter part
    def replace_func(match):
        return match.group(1)

    # Replace the patterns in the content
    updated_content = pattern.sub(replace_func, content)

    return updated_content


#########################################################################################################
################################### run_constrained_embed ###############################################

def run_constrained_embed(_full_mol_copy, _full_mol_frag, rand_seed):
    """
    Wrapper function for ConstrainedEmbed to be executed in parallel.
    :param rand_seed: Seed for random number generator.
    :return: The conformer generated by ConstrainedEmbed.
    """
    # Example usage of parameters. Adjust accordingly to your specific needs.
    ## KSP MOD 5/18/2024
    #_conf = AllChem.ConstrainedEmbed(_full_mol_copy, _full_mol_frag, useTethers=False, randomseed=rand_seed)
    
    GetFF=lambda x,confId=-1:AllChem.MMFFGetMoleculeForceField(x,AllChem.MMFFGetMoleculeProperties(x),confId=confId)
    _conf = AllChem.ConstrainedEmbed(_full_mol_copy, _full_mol_frag, useTethers=False, randomseed=rand_seed, getForceField=GetFF)
    return _conf
#########################################################################################################
#########################################################################################################


#########################################################################################################
################################### mol_from_mol2 #######################################################

def mol_from_mol2(mol2block):
    mol2block = remove_numbers_from_pattern(mol2block)
    mol = Chem.MolFromMol2Block(mol2block, sanitize=True, removeHs=False)

    return mol

#########################################################################################################
#########################################################################################################


"""
important information:

molecule name variables:
1] base_file -> e.g., "../R-ax-S_2a.mol2", base_file[3:] = "R-ax-S_2a.mol2"
2] mol2file  -> e.g., "../fragment_mol2/obabel_ClC#Cc1ccc_C_F__F_F_cc1_tmp.xyz_to.mol2", mol2file[17:] = "obabel_ClC#Cc1ccc_C_F__F_F_cc1_tmp.xyz_to.mol2"

dummy atoms:
alkyne fragment: CL
DSI-backbone: Li/Na

"""

for base_file in glob.glob("../*.mol2"):
    ## Parsing the Spartin generated mol2 file works only after removing
    ## spaces before "@<TRIPOS>BOND" 
    #mol1 = ml.Molecule.from_mol2("./2a.mol2", "BASE_TS")
    try:
        del mol1
        del join1
        del join2
    except:
        pass
    mol1 = ml.Molecule.from_mol2(base_file, f"BASE_TS_{base_file[3:]}")
    #label all bonds in this fragment so they can be identified later...
    

    TS_frags = [mol1] # make it an iterable. Add more molecules later...    
    ## lets put the molecule into a new collection
    
    collect1 = ml.Collection("TS_structures", TS_frags) # this needs to be passed an iterable
    
    ## now let's see if we can do some fragment joining!
    ## no need to grab the .cdxml file, lets grab the mol2 from RDKit/obabel
    ## "obabel_ClC#Cc1c(Br)cccc1_tmp.xyz_to.mol2"
    molecules = []
    #the following few lines will have to become part of a loop
    counter = 0
    for mol2file in glob.glob("../fragment_mol2/*xyz_to.mol2"):
        print(mol2file)
        print(mol2file[17:])
        if(counter<100):
            molecules.append(ml.Molecule.from_mol2(mol2file, name = mol2file[17:]))
        counter = counter+1
    
    
    
    #print(molecules)
    for molecule in molecules:
        molecule.atoms[molecule.get_atom_idx("CL")].swap(newlabel="D")
    
    fragment_collect = ml.Collection("molecule_test", molecules)
    fragment2_collect = ml.Collection("molecule_test2", molecules)
    
    #no need to optimize the fragments, as RDKit took care of it...
    #create xtb/crest objects
    xtb = ml.XTBDriver("sxtb", scratch_dir="./xtb_scr", nprocs=16)
    crest = ml.CRESTDriver("crest", scratch_dir="./xtb_scr3", nprocs=16)
    
        
    join1 = ml.Collection.join(collect1, fragment_collect, "Li", "D", 4.1, 1, addname="--one-name")
    join1.to_multixyz("join1_test.xyz")
    join2 = ml.Collection.join(join1, fragment_collect, "Na", "D", 4.1, 1,jointype="zip")# , addname="--one-name")
    join2.to_multixyz("join2_test.xyz")
    
    

    
    atomlist, bondlist = join2[0].recursive_atoms(["I"], n=5)
    nitrogen = []
    for bond in bondlist:
        #print(bond.a1.label)
        if "N" in bond.a1.label:
          nitrogen.append(bond.a1)
        if "N" in bond.a2.label:
            nitrogen.append(bond.a2)
    
    hydrogen = []
    for nitrogen in nitrogen:
        NBonds = join2[0].get_bonds_with_atom(nitrogen)
        for bond in NBonds:
            if "H" in bond.a1.label:
              hydrogen.append(bond.a1)
            if "H" in bond.a2.label:
              hydrogen.append(bond.a2)
    
    
    atomlist, bondlist = join2[0].recursive_atoms(hydrogen[0], n=4)
    
    
    TS_tbf = {}
    global_lock = ""
    for b in join2[0].bonds:
        if b in bondlist:
            TS_tbf[b] = join2[0].get_bond_length(b)
            #print(TS_tbf)
    for b in TS_tbf:
        a1, a2 = join2[0].get_atom_idx(b.a1), join2[0].get_atom_idx(b.a2)
        global_lock += f"  distance: {a1+1}, {a2+1}, {TS_tbf[b]:0.4f}\n"
        
    TS_tbf = {}
    atom_lock = ""
    
    atom_lock_list = [] ## keep a list of the atoms, not as a string of characters...
    for atom in atomlist:
        
        atom_lock += f" {join2[0].get_atom_idx(atom)+1},"
        atom_lock_list.append(join2[0].get_atom_idx(atom)+1)
    
    atom_lock = "atoms: " + atom_lock[:-1] + "\n $end\n"
    

    
    ########################################################################################################################################3
    ########################################################################################################################################3
    #                                print out atom labels for dispersion calculations...
    ########################################################################################################################################3
    ########################################################################################################################################3
    atom_labels = []
    all_atom_labels = []

    
    constrained_atoms = []
    constrained_coords = []
    for molecule in join2:
        atom_labels.append(molecule.name)
        print("name:", molecule.name)
        print("atoms", molecule.atoms)
        print(vars(molecule.atoms[0]))

        mol = mol_from_mol2(molecule.to_mol2_v2()) ## generate mol object from mol2, not xyz..

        
        #this should generate two lists:
        # constrained_atoms, which is a list of the atoms in the fragment that are serving as the constraint
        # constrained_coords, which is a list of the corresponding coordinates 

        for atom in molecule.atoms:
            atom_labels.append(atom.frag_label)

        all_atom_labels.append(atom_labels)    
        atom_labels = []
    
    atom_label_df = pd.DataFrame(all_atom_labels, index=None)
    #atom_label_df.to_csv("atom_fragment_labels.csv") #contains atom information...
    atom_label_df.to_csv(f"{base_file[3:]}_atom_fragment_labels.csv")

    ########################################################################################################################################3
    ########################################################################################################################################3
    #                             END - print out atom labels for dispersion calculations...
    ########################################################################################################################################3
    ########################################################################################################################################3
    

    ########################################################################################################################################3
    ########################################################################################################################################3
    #                             Begin fix_long_bonds_TS2() with atom_lock input
    ########################################################################################################################################3
    ########################################################################################################################################3
    
    

    _xtb_longbondfix = ml.Concurrent(join2, backup_dir="./xtb_scr3", logfile = f"out.log", concurrent=2, update=30, timeout = None)(xtb.fix_long_bonds_TS2)(force_const=6.0, method='gff', TS_bonds=[atom_lock])
    xtb_optimize_test = ml.Collection("test123", _xtb_longbondfix)
    xtb_optimize_test.to_multixyz(f"{base_file[3:]}_GFF_structure_gen.xyz")
    xtb_optimize_test.to_zip(f"{base_file[3:]}_GFF_structure_gen.zip")
    
    
    #### test obabel mol2 -> mol conversion so that the structure topology can be read in by RDKit
    

    
    locked_mol = mol1
    #oops, in _full_mol_frag (which is the base_TS structure), the Li/Na atoms were kept, which resulted in the first alkynic atoms being kept in "alkynes_list")
    #see below...
    #let's remove the atoms (recall, delete from locked_mol!)
    locked_mol.remove_atoms(locked_mol.get_atom("Li")) #remove the Li dummy atom from locked_mol so that it doesn't contaminate the workflow
    locked_mol.remove_atoms(locked_mol.get_atom("Na")) #also remove the Na dummy atom...
    
    ##lets generate the coordMap and try to use it as a parameter:



    replaced_atoms = [] #this is the array that holds the indexes for the replaced atoms. See the next few lines for more context
                        #note that the first index contains what used to be the hydrogen atom, the second contains a carbon atom
                        #change these back after RDKit ConstrainEmbed(), but before xtb geometry minimizations
    for xtbmol in xtb_optimize_test:
        ### the following code replaces the C/H in the N--H--C TS structure with sulfur atoms so RDKit doesn't freak out
        # instead of having to re-locate these atoms later on, let's keep track of where they are exactly (index) so we can swap them back quickly after ConstrainEmbed()
        # can get the atom index using get_atom_idx() in the molecule class
        _atomlist, _bondlist = xtbmol.recursive_atoms(["I"], n=5)

        _nitrogen = []
        for bond in _bondlist:
            if "N" in bond.a1.label:
              _nitrogen.append(bond.a1)
            if "N" in bond.a2.label:
                _nitrogen.append(bond.a2)
        
        _hydrogen = []
        for nitrogen in _nitrogen:
            NBonds = xtbmol.get_bonds_with_atom(nitrogen)
            for bond in NBonds:
                if "H" in bond.a1.label:
                  _hydrogen.append(bond.a1)
                if "H" in bond.a2.label:
                  _hydrogen.append(bond.a2)

        #instead of removing it, swap it for a sulfur... for now.... fucking RDKit
        #but first, get the index to swap back later
        replaced_atoms.append(xtbmol.get_atom_idx(_hydrogen[0]))
        _hydrogen[0].swap("S")
        

        ###find the carbon attached to "I" and make it "S" -> fuck you RDKit        
        _atomlist, _bondlist = xtbmol.recursive_atoms(["I"], n=1)
        for bond in _bondlist:
            if "C" in bond.a1.label:
                #before swapping, add to replaced_atoms
                replaced_atoms.append(xtbmol.get_atom_idx(bond.a1))
                #now swap
                bond.a1.swap("S")
            if "C" in bond.a2.label:
                #before swapping, add to replaced_atoms
                replaced_atoms.append(xtbmol.get_atom_idx(bond.a1))
                #now swap
                bond.a2.swap("S")



 
        #convert molli-readable mol2 files to rdkit-readable .mol files with openbabel:
        base_mol = ml.librarygenerate.mol2_to_mol(locked_mol, sanitize = False)
        _full_mol = ml.librarygenerate.mol2_to_mol(xtbmol, sanitize = True, removeHs = False)

        
        
        ### lets try a constrainedembed multiple times to get multiple conformers... (incorporate randomness aspect)
        #previous attempts to do constrained embeddings with base_mol failed, due to the slight differences in geometry
        ## after the xTB optimization
        ## so lets create a new temporary molecule that contains a partial list of atoms from _full_mol

        _full_mol_frag = Chem.EditableMol(Chem.MolFromMolFile(f"./{xtbmol.name}_obabel.mol", sanitize=True, removeHs = False)) # get another molecule so we can create a base_framework...
        
        full_atom_list = [item for item in range(len(xtbmol.geom.coord))] #in order
        base_atom_list = [item for item in range(len(locked_mol.geom.coord))] #in order because the alkynes are added separately
        alkynes_list = [item for item in full_atom_list if item not in base_atom_list] #in order as the differences between the lists is collected

        
        ############################################################################################################################################################################################################

        
        _full_mol_frag_tmp = Chem.MolFromMolFile(f"./{xtbmol.name}_obabel.mol", sanitize=True, removeHs = False)
        for idx in sorted(alkynes_list, reverse=True): #constrain it on the transition structure
            _full_mol_frag.RemoveAtom(idx)        
        _full_mol_frag = _full_mol_frag.GetMol()
        
        
        constrained_mols = []
        

        _full_mol_copy = deepcopy(_full_mol)
        num_rdkit_confs = 8
        
        #start_time_pool = time.time() # for pooling
        tasks = [( _full_mol_copy, _full_mol_frag, random.randrange(0, 10000)) for _ in range(8)]
        with Pool(num_rdkit_confs) as pool:

            conformers = pool.starmap(run_constrained_embed, tasks)
        constrained_mols = conformers


        ######## this embeds the conformers
        #iterate through the generated RDKit conformers... there n-conformers (determined from the range() function above). May have to find a way to prune this first..
        _molec_bin = []
        for RDKitconf in constrained_mols: #constrained_mols contains what was in _conf above
            conf = RDKitconf.GetConformer() #from the ConstrainEmbed() above
            positions = conf.GetPositions()
            atomic_numbers = [atom.GetAtomicNum() for atom in RDKitconf.GetAtoms()]
            _xyzs = f"{len(positions)}\n" #atom count
            _xyzs += " energy: 0.0 gnorm: 0.0 xtb: 0.0 (afa7bdf)\n" #header that is parsed by molli... it is the same as xtb outputs...
            #we have an array of atomic numbers an array of their respective positions. Zip the two and generate the xyz coordinate
            for atomic_num, position in zip(atomic_numbers, positions): #zip is an iterable, recall
                # Use periodic table to get the symbol
                symbol = Chem.PeriodicTable.GetElementSymbol(Chem.GetPeriodicTable(), atomic_num)
                line = f"{symbol} {position[0]:.4f} {position[1]:.4f} {position[2]:.4f}"
                _xyzs += f"{line}\n"            
            
            #recall, xtbmol was obtained from xtb_optimize_test and is part of this large for loop!
            _dummy_mol = deepcopy(xtbmol) #generate a temporary dummy molecule so we can update the coordinates
            #add the xyz coordinates to the dummy molecule
            _dummy_mol.update_geom_from_xyz(_xyzs) #(self, xyzblock: str, assert_single=False):
            #add the other conformers generated by RDKit
            xtbmol.conformed_conformers.append(_xyzs) #this doesn't work because of the atom swap :@
            xtbmol.embed_conformers(_dummy_mol.geom,mode="a") # this should modify "xtb_optimize_test"
            #checking the number of conformers here turns up the exact number expected from the range() function above

        #instead of iterating through the molecules again, just swap back the atoms here...
        #the atoms are in "replaced_atoms", the hydrogen atom is first, followed by the carbon atom
        if(xtbmol.atoms[replaced_atoms[0]].label == "S" and xtbmol.atoms[replaced_atoms[1]].label == "S"):
            xtbmol.atoms[replaced_atoms[0]].swap("H")
            xtbmol.atoms[replaced_atoms[1]].swap("C")
        #atoms are replaced now, and should be OK to be put into xtb for geometry optimization+energy calculations
        
    #current modification has xtb_optimize_test being modified "inplace". let's see if that works better...
    _xtb_minimized = ml.Concurrent(xtb_optimize_test, backup_dir="./xtb_scr5", logfile = f"out_minimized2.log", concurrent=6, update=30, timeout=None)(xtb.optimize_conformers_TS)(force_const=6.0, method='gfn2', TS_bonds=[atom_lock])

    xtb_minimized = deepcopy(xtb_optimize_test) #this is to avoid changing the name of all the following variables...
    
    ########################################################################################################################################3
    ########################################################################################################################################3
    #                                GET MOLECULE ENERGIES
    ########################################################################################################################################3
    ########################################################################################################################################3
    
    #recall, at this stage xtb_minimized is a collection that contains alkynes with only one substrate
    start1 = time.time()
    for molecule in xtb_minimized:
        #molecule.conformer_energies = asyncio.run(xtb.conformer_energies(molecule, method="gfn2"))
        molecule.conformer_energies = asyncio.run(xtb.conformer_energies_independent(molecule, method="gfn2")) # new version, test
        #ok, the energies are collected for each molecule. Let's keep only the lowest energy conformer
        
        print("molecule.conformer_energies", molecule.conformer_energies)
        #x=input()
        _loc = np.where(molecule.conformer_energies==(molecule.conformer_energies.min()))[-1].squeeze()
        print("_loc", _loc)
        #print(molecule.conformer_energies)
        #x=input("check loc\n\n")
        #On rare occasions, _loc gets two structures due to degeneracies. 
        
        # KSP mod 4/28/2024
        try:
            if(len(_loc)>1):
              _loc = _loc[0]
        except:
            pass
        molecule.update_geom_from_xyz(molecule.to_xyz(n=_loc, header=True))

    for molec in xtb_minimized:
        print(molec.conformer_energies)

    xtb_minimized.to_multixyz(f"final_multi_xyz_{base_file[3:]}_xtb_minimized_inplace_mod_gfn2.xyz")
    xtb_minimized.to_zip(f"final_zip_{base_file[3:]}_xtb_inplace_mod_minimized_gfn2.zip")
            
    all_molecule_energies = [] 
    molecule_names = []  
    for molecule in xtb_minimized:
        all_molecule_energies.append(molecule.xtb_energy)
        molecule_names.append(molecule.name)
    all_molecule_energies_df = pd.DataFrame(all_molecule_energies, index=None)
    all_molecule_energies_df = pd.concat([pd.DataFrame(molecule_names), all_molecule_energies_df],axis=1)
    print("CHECKING ALL_ENERGIES", all_molecule_energies_df)
    #x=input()
    all_molecule_energies_df.to_csv(f"{base_file[3:]}_molecule_energies.csv")
    ############################################################################################################################################################################
    ###################################################################################### checking RSSD #######################################################################
    print("======================================")
    angle_data = "number, name, angle\n"
    for n, molecule in enumerate(xtb_minimized):
    
      
        ## the above checks the alignment of the TS core structure with the Kabsch algorithm, unfortunately, the backbone doesn't change very much
        ## failures in the alignment are due to non-linear alkynes. This should be adjusted here.
    
        #lets make the Kabsch check general, in the sense that we don't have to specify the exact number of atoms
        #base_TS_len = len(mol1.geom.coord[:-2]) #get the length of the base_TS (will change depending on the exact substrate used
        #print("Kabsch: ", Rotation.align_vectors(mol1.geom.coord[:-2], molecule.geom.coord[0:base_TS_len]))
    
        # lets also check how linear the alkyne is! the indices sp2(binol)-sp(alkyne)-sp(alkyne) chain of three atoms are found within join1[n].important_atoms and join2[n].important_atoms
        # note that xtb_optimize_test is a collection that contains the actual atoms (after optimization). This collection contains the geometries that should be examined!
        
        v1 = molecule.geom.coord[join1[n].important_atoms[0]]-molecule.geom.coord[join1[n].important_atoms[1]-3]
        v2 = molecule.geom.coord[join1[n].important_atoms[1]-3]-molecule.geom.coord[join1[n].important_atoms[2]-3]

        dot_product = np.dot(v1, v2)
        norm_v1 = np.linalg.norm(v1)
        norm_v2 = np.linalg.norm(v2)
        
        cos_angle = dot_product/(norm_v1*norm_v2)
        cos_angle = np.clip(cos_angle,-1,1)
        angle_radians = np.arccos(cos_angle)
        angle_degrees = np.degrees(angle_radians)
        
        print("ANGLE:", angle_degrees)
        angle_data += f"{n}, {molecule.name}, {angle_degrees}\n"
        

    with open(f"{base_file[3:]}_angle_checks", "w+") as f:
        f.write(angle_data)

    del join1
    del join2
    
### end large for loop (iterating through each structure)

############################################################################################################################################################################
############################################################################################################################################################################

print("completed, exiting...")
exit()   



