import subprocess
import os
import rdkit
from rdkit import Chem
import pandas as pd
import substructure #### CHANGE TO rdkittools
from multiprocessing import Pool
import random
from copy import deepcopy

from rdkit import Chem
from rdkit.Chem import AllChem
from rdkit.Chem import Draw,PyMol,MCS
from rdkit import rdBase

#misc functions here



#convert mol to mol2 with obabel
def mol2_to_mol(molobj, sanitize = False, removeHs = True, name = None):
    
    if(name==None):
        name = f"{molobj.name}_obabel.mol"
    else:
        try:
            name = str(name)
        except:
            name = "_mol.mol"
    inputline =  f"obabel -imol2 -omol -O {molobj.name}_obabel.mol << EOF \n"
    inputline += f"{molobj.to_mol2()}"
    inputline += f" EOF "
    execute = subprocess.run(inputline, shell=True)
    
    return Chem.MolFromMolFile(f"{molobj.name}_obabel.mol", sanitize = sanitize, removeHs = removeHs)

def label_collection(collection, label):
    for molecule in collection:
        label_molecule(molecule, label)
    

def label_molecule(molecule, label):
    for atom in molecule.atoms:
        print(atom)
        atom.frag_label = label

def print_labels(collection, name):
    atom_labels = []
    all_atom_labels = []
    # constrained_atoms = []
    # constrained_coords = []
    for molecule in collection:
        atom_labels.append(molecule.name)
        for atom in molecule.atoms:
            atom_labels.append(atom.frag_label)
        all_atom_labels.append(atom_labels)    
        atom_labels = []  
    atom_label_df = pd.DataFrame(all_atom_labels, index=None)
    atom_label_df.to_csv(f"{name}_atom_fragment_labels.csv")
    #atom_label_df.to_csv(f"{base_file[3:]}_atom_fragment_labels.csv")


def get_crest_lock_list(molecule, atomlist):
    TS_tbf = {}
    atom_lock = ""
    atom_lock_list = []
    for atom in atomlist:
        atom_lock += f" {molecule.get_atom_idx(atom)+1},"
        atom_lock_list.append(molecule.get_atom_idx(atom)+1)
    atom_lock = "atoms: " + atom_lock[:-1] + "\n $end\n"
    return atom_lock

def run_constrained_embed(_full_mol_copy, _full_mol_frag, rand_seed):
    """
    Wrapper function for ConstrainedEmbed to be executed in parallel.
    :param rand_seed: Seed for random number generator.
    :return: The conformer generated by ConstrainedEmbed.
    """
    # Example usage of parameters. Adjust accordingly to your specific needs.
    ## KSP MOD 5/18/2024
    #_conf = AllChem.ConstrainedEmbed(_full_mol_copy, _full_mol_frag, useTethers=False, randomseed=rand_seed)
    
    GetFF=lambda x,confId=-1:AllChem.MMFFGetMoleculeForceField(x,AllChem.MMFFGetMoleculeProperties(x),confId=confId)
    _conf = AllChem.ConstrainedEmbed(_full_mol_copy, _full_mol_frag, useTethers=False, randomseed=rand_seed, getForceField=GetFF)
    return _conf



def rdkitconfs(molecule,  mol_a, mol_b, num_confs = 8):
    tasks = [( mol_a, mol_b, random.randrange(0, 10000)) for _ in range(num_confs)]
    with Pool(num_confs) as pool:
        conformers = pool.starmap(run_constrained_embed, tasks)
    constrained_mols = conformers
    # _molec_bin = []
    for RDKitconf in constrained_mols: #constrained_mols contains what was in _conf above
        conf = RDKitconf.GetConformer() #from the ConstrainEmbed() above
        positions = conf.GetPositions()
        atomic_numbers = [atom.GetAtomicNum() for atom in RDKitconf.GetAtoms()]
        _xyzs = f"{len(positions)}\n" #atom count
        _xyzs += " energy: 0.0 gnorm: 0.0 xtb: 0.0 (afa7bdf)\n" #header that is parsed by molli... it is the same as xtb outputs...
        #we have an array of atomic numbers an array of their respective positions. Zip the two and generate the xyz coordinate
        for atomic_num, position in zip(atomic_numbers, positions): #zip is an iterable, recall
            # Use periodic table to get the symbol
            symbol = Chem.PeriodicTable.GetElementSymbol(Chem.GetPeriodicTable(), atomic_num)
            line = f"{symbol} {position[0]:.4f} {position[1]:.4f} {position[2]:.4f}"
            _xyzs += f"{line}\n"            
        print("MADE IT HERE!")
        #recall, xtbmol was obtained from xtb_optimize_test and is part of this large for loop!
        _dummy_mol = deepcopy(molecule) #generate a temporary dummy molecule so we can update the coordinates
        #add the xyz coordinates to the dummy molecule
        _dummy_mol.update_geom_from_xyz(_xyzs) #(self, xyzblock: str, assert_single=False):
        #add the other conformers generated by RDKit
        molecule.conformed_conformers.append(_xyzs) #this doesn't work because of the atom swap :@
        molecule.embed_conformers(_dummy_mol.geom,mode="a") # this should modify "xtb_optimize_test"
        #checking the number of conformers here turns up the exact number expected from the range() function above
  
    return molecule


