"""
This file seeks to construct the library of DSI-substrate pairs that approximate
the computed transition states. The workflow will differ from the typical one
using Molli because the base structure will not start from a CDXML file.

However, the fragments likely need to be constructed from CDXML files.

Need to construct a molli object for the base structure (can be lazy and
have one for each of the 13 DSI-Substrate pairs). 

Starting from Mol2 files that already contain bonding information is likely
the easiest way. These can be generated with Spartan. 

First test: Generate Molli objects with Spartan generated Mol2 files

2012-12-26
this file also generates conformers of the joined structures using RDKit, but makes sure
that the correct atoms are locked

"""

print("WARNING - changed concurrent to 6")

import molli as ml
import glob
import os
import numpy as np
import pandas as pd


#molli imports
from molli.dtypes import CartesianGeometry


#RDKit imports
from rdkit import Chem
from rdkit.Chem import AllChem
from rdkit.Chem import Draw,PyMol,MCS
from rdkit import rdBase

#other imports
import subprocess 
import random
import asyncio 
import os 
import re 
from copy import deepcopy
import numpy as np
from multiprocessing import Pool
import time

import substructure #### CHANGE TO rdkittools


import networkx as nx #networkx for graphs
from networkx.algorithms import isomorphism
#custom imports:
#import get_pid



#########################################################################################################
################################### run_constrained_embed ###############################################
def GetUFF(mol, confId=-1):
    return AllChem.UFFGetMoleculeForceField(mol, confId=confId)

def run_constrained_embed_2(_full_mol_copy, _full_mol_frag, rand_seed):
    """
    Wrapper function for ConstrainedEmbed to be executed in parallel.
    :param rand_seed: Seed for random number generator.
    :return: The conformer generated by ConstrainedEmbed.
    """
    # Example usage of parameters. Adjust accordingly to your specific needs.
    ## KSP MOD 5/18/2024
    #_conf = AllChem.ConstrainedEmbed(_full_mol_copy, _full_mol_frag, useTethers=False, randomseed=rand_seed)
    
    GetFF=lambda x,confId=-1:AllChem.MMFFGetMoleculeForceField(x,AllChem.MMFFGetMoleculeProperties(x),confId=confId)
    
    _conf = AllChem.ConstrainedEmbed(_full_mol_copy, _full_mol_frag, useTethers=True, randomseed=rand_seed, getForceField=GetUFF)
    return _conf
#########################################################################################################
#########################################################################################################


"""
important information:

molecule name variables:
1] base_file -> e.g., "../R-ax-S_2a.mol2", base_file[3:] = "R-ax-S_2a.mol2"
2] mol2file  -> e.g., "../fragment_mol2/obabel_ClC#Cc1ccc_C_F__F_F_cc1_tmp.xyz_to.mol2", mol2file[17:] = "obabel_ClC#Cc1ccc_C_F__F_F_cc1_tmp.xyz_to.mol2"

dummy atoms:
alkyne fragment: CL
DSI-backbone: Li/Na

"""

for base_file in glob.glob("../*.mol2"):
    ## Parsing the Spartin generated mol2 file works only after removing
    ## spaces before "@<TRIPOS>BOND" 
    try:
        del mol1
        del join1
        del join2
    except:
        pass
    
    #create molecule collections for fragments and core
    #
    #create a collection for the base structure
    mol1 = ml.Molecule.from_mol2(base_file, f"BASE_TS_{base_file[3:]}")
    TS_frags = [mol1] # make it an iterable. Add more molecules later...    
    collect1 = ml.Collection("TS_structures", TS_frags) # this needs to be passed an iterable
    #create molecule objects from the alkyne fragment list so that a collection can be generated
    molecules = []
    counter = 0
    for mol2file in glob.glob("../fragment_mol2/*xyz_to.mol2"):
        print(mol2file)
        print(mol2file[17:])
        if(counter<100):
            molecules.append(ml.Molecule.from_mol2(mol2file, name = mol2file[17:]))
        counter = counter+1
    #prepare the fragments created by RDKit (replace "CL" with the atom used in the substituent list
    #       passed to "SubstituentCreate()"
    #create the collection
    for molecule in molecules:
        molecule.atoms[molecule.get_atom_idx("CL")].swap(newlabel="D") 
    fragment_collect = ml.Collection("molecule_test", molecules)

    #instantiate xtb/crest drivers with 16 processors each
    xtb = ml.XTBDriver("sxtb", scratch_dir="./xtb_scr", nprocs=16)
    crest = ml.CRESTDriver("crest", scratch_dir="./crest_scr2", nprocs=16)
    
    #generate the library
    #
    #
    # find the iodine, as it will serve as the central point in the base fragment for the fragment rotations
    
    #
    #join the first alkyne
    ml.librarygenerate.label_collection(collect1, 1) # label the base structure "1"
    ml.librarygenerate.label_collection(fragment_collect, 2) # label the first alkyne "2"
    central_atom = collect1[0].get_atom_idx("B") # get the atom index as a handle
    join1 = ml.Collection.join(collect1, fragment_collect, "Li", "D", 4.1, 1, addname="--one-name", rotations=[2,5], central_atom = central_atom)
    join1.to_multixyz("join1_test.xyz") #output joined structure (no bond)
    #join the second alkyne - need to use jointype = "zip" to avoid comb. enum. (results in mixing of alkynes)
    #y=input("wut")
    central_atom = join1[0].get_atom_idx("B") # get the atom index as a handle - should remain the same, but just in case
    ml.librarygenerate.label_collection(fragment_collect, 2) # label the second alkyne "3"
    join2 = ml.Collection.join(join1, fragment_collect, "Na", "D", 4.1, 1,jointype="zip", rotations=[2,5], central_atom = central_atom)# , addname="--one-name")
    join2.to_multixyz("join2_test.xyz") #output joined structure (no bonds)

    central_atom = join2[0].get_atom_idx("B") # get the atom index as a handle - should remain the same, but just in case
    ml.librarygenerate.label_collection(fragment_collect, 2) # label the second alkyne "3"
    join2 = ml.Collection.join(join2, fragment_collect, "K", "D", 4.1, 1,jointype="zip", rotations=[2,5], central_atom = central_atom)# , addname="--one-name")
    join2.to_multixyz("join2_test.xyz") #output joined structure (no bonds)
    
    # the following code identifies the transition state core automatically in each structure
    # this code should be replaced as needed for new structures
    #
    # step 1: find the iodine atom (it is unique in each transition state), you can use substructure matching as well
    #           use the iodine to trace bonds until nitrogens are found, collect them

    ### \/
    print("base_file", base_file)
    print("atoms", join2[0].atoms)
    print("join2", join2[0].get_atom_idx("Pd"))
    #x=input("see")
    boron_source = ml.librarygenerate.mol2_to_mol(join2[0], sanitize = False, removeHs = False)#, name=f"{xtbmol.name}_original.mol")
    #highvalent_list , _ = substructure.swap_high_valent(boron_source, atoms = [join2[0].get_atom_idx("Pd")]) #identify the active proton by its presence as the only "high valent proton"!
    
    #print(highvalent_list)
    #exit()
    #_proton = next((k for k, v in highvalent_list.items() if v == 'H'), None)
    
    atomlist, bondlist = join2[0].recursive_atoms(join2[0].atoms[central_atom], n=4)
    print("after", atomlist, bondlist)
    #$% testing ^

    #generate the list of atoms to lock for crest...
    atom_lock = ml.librarygenerate.get_crest_lock_list(join2[0], atomlist)
    ml.librarygenerate.print_labels(join2, base_file[3:])
    

    #printout the atom labels for the molecules (now joined)
    #this helps keep track of the substituents for descriptors
    #$%
    


    #fix initially generated structure with longbond join for TS structures
    _xtb_longbondfix = ml.Concurrent(join2, backup_dir="./xtb_scr3", logfile = f"out.log", concurrent=2, update=30, timeout = None)(xtb.fix_long_bonds_TS2)(force_const=6.0, method='gff', TS_bonds=[atom_lock])
    xtb_optimize_test = ml.Collection("test123", _xtb_longbondfix)
    xtb_optimize_test.to_multixyz(f"{base_file[3:]}_GFF_structure_gen.xyz")
    xtb_optimize_test.to_zip(f"{base_file[3:]}_GFF_structure_gen.zip")
    
    
    #### test obabel mol2 -> mol conversion so that the structure topology can be read in by RDKit
    

    
    locked_mol = mol1
    #oops, in _full_mol_frag (which is the base_TS structure), the Li/Na atoms were kept, which resulted in the first alkynic atoms being kept in "alkynes_list")
    #see below...
    #let's remove the atoms (recall, delete from locked_mol!)
    locked_mol.remove_atoms(locked_mol.get_atom("Li")) #remove the Li dummy atom from locked_mol so that it doesn't contaminate the workflow
    locked_mol.remove_atoms(locked_mol.get_atom("Na")) #also remove the Na dummy atom...
    locked_mol.remove_atoms(locked_mol.get_atom("K"))
    


    #the following code generates conformers with RDKit
    #the code is heavily customized here for the DSI-TS structure, this part can be replaced with a separate conformer generation method
    #note that some atoms need to be swapped to accomodate the increase in valency (e.g., N--H--C fragment). 
    #this has no impact on conformer generation as these atoms are frozen
    replaced_atoms = [] #this is the array that holds the indexes for the replaced atoms.
                        #change these back after RDKit ConstrainEmbed(), but before xtb geometry minimizations
    for xtbmol in xtb_optimize_test:

        
        #convert molli mol to rdkit mol,
        original_atoms = ml.librarygenerate.mol2_to_mol(xtbmol, sanitize = False, removeHs = False)#, name=f"{xtbmol.name}_original.mol")
        
        ###########################################################################################################
        swapped_list, _ = substructure.swap_high_valent(original_atoms, atoms = [join2[0].get_atom_idx("Pd")])
        replaced_atoms = list(swapped_list.keys())[::-1]

        for item in swapped_list:
            xtbmol.atoms[item].swap("S")
        
        tsmolobj = ml.librarygenerate.mol2_to_mol(xtbmol, sanitize = False, removeHs = False) #rewrite the molecule

        #convert molli-readable mol2 files to rdkit-readable .mol files with openbabel:
        #base_mol = ml.librarygenerate.mol2_to_mol(base_mol, sanitize = False)
        _full_mol = ml.librarygenerate.mol2_to_mol(xtbmol, sanitize = False, removeHs = False) #swapping to false fixed it...?
        #>^_full_mol = ml.librarygenerate.mol2_to_mol(xtb_swapped, sanitize = True, removeHs = False)
        #_full_mol_frag = Chem.EditableMol(Chem.MolFromMolFile(f"./{xtbmol.name}_obabel.mol", sanitize=True, removeHs = False)) # get another molecule so we can create a base_framework...
        _full_mol_frag = Chem.EditableMol(Chem.MolFromMolFile(f"./{xtbmol.name}_obabel.mol", sanitize=False, removeHs = False))
        full_atom_list = [item for item in range(len(xtbmol.geom.coord))] #in order
        base_atom_list = [item for item in range(len(locked_mol.geom.coord))] #in order because the alkynes are added separately
        alkynes_list = [item for item in full_atom_list if item not in base_atom_list] #in order as the differences between the lists is collected


        
        for idx in sorted(alkynes_list, reverse=True): #constrain it on the transition structure
            _full_mol_frag.RemoveAtom(idx)        
        _full_mol_frag = _full_mol_frag.GetMol()
        _full_mol_copy = deepcopy(_full_mol)


        """
        #the following checks the fragment/full molecule coordinates - is that the issue with constrainedembed?
        conf = _full_mol_copy.GetConformer(0)
        num_atoms = _full_mol_copy.GetNumAtoms()
        print(num_atoms)
        print("XYZ coordinates from RDKit _full_mol_copy")
        for i in range(num_atoms):
            atom = _full_mol_copy.GetAtomWithIdx(i)
            pos = conf.GetAtomPosition(i)
            print(f"{atom.GetSymbol():<2} {pos.x:>10.6f} {pos.y:>10.6f} {pos.z:>10.6f}")
            
        conf = _full_mol_frag.GetConformer(0)
        num_atoms = _full_mol_frag.GetNumAtoms()
        print(num_atoms)
        print("XYZ coordinates from RDKit _full_mol_frag")
        for i in range(num_atoms):
            atom = _full_mol_frag.GetAtomWithIdx(i)
            pos = conf.GetAtomPosition(i)
            print(f"{atom.GetSymbol():<2} {pos.x:>10.6f} {pos.y:>10.6f} {pos.z:>10.6f}")
        """
        print(xtbmol.geom.coord)
        print(locked_mol.geom.coord)

        #generate the rdkit conformers
        #print(xtbmol.atoms, _full_mol_copy.atoms, _full_mol_frag.atoms)
        
        #check sanitization
        #print(Chem.SanitizeMol(_full_mol_copy, sanitizeOps=Chem.SanitizeFlags.SANITIZE_ALL ^ Chem.SanitizeFlags.SANITIZE_KEKULIZE))
        #print(Chem.SanitizeMol(_full_mol_frag, sanitizeOps=Chem.SanitizeFlags.SANITIZE_ALL ^ Chem.SanitizeFlags.SANITIZE_KEKULIZE))
        """
        Chem.Kekulize(_full_mol_copy, clearAromaticFlags = True)
        print("kekulize1", Chem.MolToSmiles(_full_mol_copy, kekuleSmiles=True))
        print(AllChem.MMFFGetMoleculeProperties(_full_mol_copy))
        Chem.Kekulize(_full_mol_frag, clearAromaticFlags = True)
        print("kekulize2", Chem.MolToSmiles(_full_mol_frag, kekuleSmiles=True))
        #print(AllChem.MMFFGetMoleculeProperties(_full_mol_frag))


        print("look above")
        exit()
        """
        # GetFF=lambda x,confId=-1:AllChem.MMFFGetMoleculeForceField(x,AllChem.MMFFGetMoleculeProperties(x),confId=confId)
        # _conf = AllChem.ConstrainedEmbed(_full_mol_copy, _full_mol_frag, useTethers=False, randomseed=42, getForceField=GetFF)

        # tasks = [( _full_mol_copy, _full_mol_frag, 4) for _ in range(4)] #random.randrange(0, 10000)) for _ in range(1)]
        # with Pool(8) as pool:
        #     conformers = pool.starmap(run_constrained_embed_2, tasks)
        # constrained_mols = conformers
        GetFF=lambda x,confId=-1:AllChem.MMFFGetMoleculeForceField(x,AllChem.MMFFGetMoleculeProperties(x),confId=confId)
        rdkit_confs=[]
        for num,_confrun in enumerate(range(8)):
            rdkit_confs.append(AllChem.ConstrainedEmbed(_full_mol_copy, _full_mol_frag, useTethers=False, randomseed=num, getForceField=GetUFF))


        #the following checks the fragment/full molecule coordinates - is that the issue with constrainedembed?
        print(rdkit_confs[0], type(rdkit_confs[0]))
        conf = rdkit_confs[0].GetConformer(0)
        num_atoms = _full_mol_copy.GetNumAtoms()
        print(num_atoms)
        print("XYZ coordinates from RDKit _full_mol_copy")
        for i in range(num_atoms):
            atom = _full_mol_copy.GetAtomWithIdx(i)
            pos = conf.GetAtomPosition(i)
            print(f"{atom.GetSymbol():<2} {pos.x:>10.6f} {pos.y:>10.6f} {pos.z:>10.6f}")

        conf = conf = rdkit_confs[1].GetConformer(0)
        num_atoms = _full_mol_copy.GetNumAtoms()
        print(num_atoms)
        print("XYZ coordinates from RDKit _full_mol_copy")
        for i in range(num_atoms):
            atom = _full_mol_copy.GetAtomWithIdx(i)
            pos = conf.GetAtomPosition(i)
            print(f"{atom.GetSymbol():<2} {pos.x:>10.6f} {pos.y:>10.6f} {pos.z:>10.6f}")
            
        print("SEE ABOVE")
        #conformers = run_constrained_embed_2(_full_mol_copy, _full_mol_frag, 4)
        x=input("confs")
        constrained_mols = rdkit_confs
         # _molec_bin = []
        for RDKitconf in constrained_mols: #constrained_mols contains what was in _conf above
            conf = RDKitconf.GetConformer() #from the ConstrainEmbed() above
            positions = conf.GetPositions()
            atomic_numbers = [atom.GetAtomicNum() for atom in RDKitconf.GetAtoms()]
            _xyzs = f"{len(positions)}\n" #atom count
            _xyzs += " energy: 0.0 gnorm: 0.0 xtb: 0.0 (afa7bdf)\n" #header that is parsed by molli... it is the same as xtb outputs...
            #we have an array of atomic numbers an array of their respective positions. Zip the two and generate the xyz coordinate
            for atomic_num, position in zip(atomic_numbers, positions): #zip is an iterable, recall
                # Use periodic table to get the symbol
                symbol = Chem.PeriodicTable.GetElementSymbol(Chem.GetPeriodicTable(), atomic_num)
                line = f"{symbol} {position[0]:.4f} {position[1]:.4f} {position[2]:.4f}"
                _xyzs += f"{line}\n"            
            print("MADE IT HERE!")
            #recall, xtbmol was obtained from xtb_optimize_test and is part of this large for loop!
            _dummy_mol = deepcopy(xtbmol) #generate a temporary dummy molecule so we can update the coordinates
            #add the xyz coordinates to the dummy molecule
            _dummy_mol.update_geom_from_xyz(_xyzs) #(self, xyzblock: str, assert_single=False):
            #add the other conformers generated by RDKit
            xtbmol.conformed_conformers.append(_xyzs) #this doesn't work because of the atom swap :@
            xtbmol.embed_conformers(_dummy_mol.geom,mode="a") # this should modify "xtb_optimize_test"

        print("...")
        
        #ml.librarygenerate.rdkitconfs(xtbmol, _full_mol_copy, _full_mol_frag, num_confs = 1)


        #the following code does nothing productive, but demonstrates substructure searching functionality
        # DSI_backbone_smi = "O=S1(C2=C(C3=C([H])C([H])=C([H])C([H])=C3C([H])=C2)C4=C5C([H])=C([H])C([H])=C([H])C5=C([H])C=C4S(N1[H])(=O)=O)=O" # "O=S1(C2=C(C3=C(C=CC=C4)C4=CC=C3S([N]1)(=O)=O)C5=CC=CC=C5C=C2)=O"  
        # DSI_mol = Chem.MolFromSmiles(DSI_backbone_smi, sanitize=False)
        # DSI_mol_nx = substructure.mol_to_nx(DSI_mol)
        # tsmolgraph = substructure.mol_to_nx(tsmolobj)
        # matches = substructure.subgraph_matches_nx(DSI_mol_nx, tsmolgraph)

        print("..)")
        #instead of iterating through the molecules again, just swap back the atoms here...
        #the atoms are in "replaced_atoms", the hydrogen atom is first, followed by the carbon atom
        if(xtbmol.atoms[replaced_atoms[0]].label == "S" and xtbmol.atoms[replaced_atoms[1]].label == "S"):
            xtbmol.atoms[replaced_atoms[0]].swap("H")
            xtbmol.atoms[replaced_atoms[1]].swap("C")
        print("..)..")
        #atoms are replaced now, and should be OK to be put into xtb for geometry optimization+energy calculations
    # end RDKit based conformer generation (replace above with different method if desired)
    
    #once the conformers are generated, reminimize with xtb
    #current modification has xtb_optimize_test being modified "inplace". let's see if that works better...
    _xtb_minimized = ml.Concurrent(xtb_optimize_test, backup_dir="./xtb_scr5", logfile = f"out_minimized2.log", concurrent=6, update=30, timeout=None)(xtb.optimize_conformers_TS)(force_const=6.0, method='gfn2', TS_bonds=[atom_lock])
    xtb_minimized = deepcopy(xtb_optimize_test) #this is to avoid changing the name of all the following variables...

    #prune the molecules, keep the lowest energy conformer
    for molecule in xtb_minimized:
        #molecule.conformer_energies = asyncio.run(xtb.conformer_energies(molecule, method="gfn2"))
        molecule.conformer_energies = asyncio.run(xtb.conformer_energies_independent(molecule, method="gfn2")) # new version, test
        #keep lowest energy
        _loc = np.where(molecule.conformer_energies==(molecule.conformer_energies.min()))[-1].squeeze()
        #On rare occasions, _loc gets two structures due to degeneracies. 
        try:
            if(len(_loc)>1):
              _loc = _loc[0]
        except:
            pass
        molecule.update_geom_from_xyz(molecule.to_xyz(n=_loc, header=True))



    xtb_minimized.to_multixyz(f"final_multi_xyz_{base_file[3:]}_xtb_minimized_inplace_mod_gfn2.xyz")
    xtb_minimized.to_zip(f"final_zip_{base_file[3:]}_xtb_inplace_mod_minimized_gfn2.zip")

    ############################################################################################################################################################################
    ###################################################################################### checking RSSD #######################################################################
    print("======================================")
    angle_data = "number, name, angle\n"
    for n, molecule in enumerate(xtb_minimized):
    
      
        ## the above checks the alignment of the TS core structure with the Kabsch algorithm, unfortunately, the backbone doesn't change very much
        ## failures in the alignment are due to non-linear alkynes. This should be adjusted here.
    
        #lets make the Kabsch check general, in the sense that we don't have to specify the exact number of atoms
        #base_TS_len = len(mol1.geom.coord[:-2]) #get the length of the base_TS (will change depending on the exact substrate used
        #print("Kabsch: ", Rotation.align_vectors(mol1.geom.coord[:-2], molecule.geom.coord[0:base_TS_len]))
    
        # lets also check how linear the alkyne is! the indices sp2(binol)-sp(alkyne)-sp(alkyne) chain of three atoms are found within join1[n].important_atoms and join2[n].important_atoms
        # note that xtb_optimize_test is a collection that contains the actual atoms (after optimization). This collection contains the geometries that should be examined!
        
        v1 = molecule.geom.coord[join1[n].important_atoms[0]]-molecule.geom.coord[join1[n].important_atoms[1]-3]
        v2 = molecule.geom.coord[join1[n].important_atoms[1]-3]-molecule.geom.coord[join1[n].important_atoms[2]-3]

        dot_product = np.dot(v1, v2)
        norm_v1 = np.linalg.norm(v1)
        norm_v2 = np.linalg.norm(v2)
        
        cos_angle = dot_product/(norm_v1*norm_v2)
        cos_angle = np.clip(cos_angle,-1,1)
        angle_radians = np.arccos(cos_angle)
        angle_degrees = np.degrees(angle_radians)
        
        print("ANGLE:", angle_degrees)
        angle_data += f"{n}, {molecule.name}, {angle_degrees}\n"
        

    with open(f"{base_file[3:]}_angle_checks", "w+") as f:
        f.write(angle_data)

    #clean up
    del join1
    del join2
    
### end large for loop (iterating through each structure)


print("completed, exiting...")
exit()   



